## Serial 收集器
串行收集器是最基本的垃圾收集器了,它是一个单线程收集器。它的"单线程"不仅仅是它只会使用一条垃圾收集线程去完成垃圾收集工作,更重要的是它在进行垃圾收集工作的时候必须暂停其它所有的工作线程(Stop The world),直到它收集结束.

## ParNew 收集器
ParNew 收集器其实就是Serial 收集器的多线程版本,除了在使用多线程进行垃圾收集外,它的参数,收集算法,回收策略和Serial 收集器完全一样。
新生代采用标记-复制算法，老年代采用标记-整理算法。

## CMS 收集器
CMS 收集器是一种以获取最短回收停顿时间为目标的收集器。
CSM 收集器是一种"标记-清除" 算法实现的,但是它比串行/并行的垃圾收集器来说更加复杂。主要过程有4步。
1. 初始标记： 暂停所有的其他线程，并记录下直接与 root 相连的对象，速度很快。
2. 并发标记：  同时开启 GC 和用户线程，用一个闭包结构去记录可达对象。但在这个阶段结束，这个闭包结构并不能保证包含当前所有的可达对象。因为用户线程可能会不断的更新引用域，所以 GC 线程无法保证可达性分析的实时性。所以这个算法里会跟踪记录这些发生引用更新的地方。
3. 重新标记： 重新标记阶段就是为了修正并发标记期间因为用户程序继续运行而导致标记产生变动的那一部分对象的标记记录，这个阶段的停顿时间一般会比初始标记阶段的时间稍长，远远比并发标记阶段时间短
4. 并发清除： 开启用户线程，同时 GC 线程开始对未标记的区域做清扫。

### 可作为 GC Roots 的对象包括下面几种:
1. 虚拟机栈(栈帧中的本地变量表)中引用的对象
2. 本地方法栈(Native 方法)中引用的对象
3. 方法区中类静态属性引用的对象
4. 方法区中常量引用的对象
5. 所有被同步锁持有的对象
### 缺点
1. 比较消耗CPU资源
2. 它使用的回收算法 "标记-清除" 会导致收集结束时有大量的空间碎片产生。

## G1 收集器
G1 (Garbage-First) 是一款面向服务器的垃圾收集器,主要针对配备多颗处理器及大容量内存的机器,能在满足GC停顿时间要求的同时,还具备高吞吐量的性能特征。

### 优点
1. 并行与并发: G1 能充分利用 CPU、多核,来缩短 Stop-The-World 停顿时间。
2. 可预测的停顿：G1 除了追求低停顿外，还能建立可预测的停顿时间模型，能让使用者明确指定在一个长度为 M 毫秒的时间片段内。
3. 优先收集：G1维护了一个优先列表，每次根据允许的收集时间，优先选择回收价值最大的Region。这种使用Region划分内存空间以及有优先级的区域回收方式，保证了G1在有限时间内可以尽可能高的收集效率。

## ZGC
ZGC也采用标记-复制算法，不过ZGC对该算法做了重大改进：ZGC在标记、转移和重定位阶段几乎都是并发的
ZGC只有三个STW阶段：初始标记，再标记，初始转移。其中，初始标记和初始转移分别都只需要扫描所有GC Roots，其处理时间和GC Roots的数量成正比，一般情况耗时非常短；再标记阶段STW时间很短，最多1ms，超过1ms则再次进入并发标记阶段。即，ZGC几乎所有暂停都只依赖于GC Roots集合大小，停顿时间不会随着堆的大小或者活跃对象的大小而增加。与ZGC对比，G1的转移阶段完全STW的，且停顿时间随存活对象的大小增加而增加。